from collections import Counter, defaultdict

import igraph as ig
import numpy as np
import pandas as pd
from tqdm import tqdm


def vulnerabilities_per_community(graph, communities, vulns):
    vuln_communities = []
    community_vulns = defaultdict(list)
    for _, vuln in tqdm(
        vulns.iterrows(), desc="Enumerating vulnerabilities", total=len(vulns)
    ):
        try:
            vuln_id = graph.vs.find(name=vuln["package"]).index
            comm = communities.membership[vuln_id]
            vuln_communities.append(comm)
            community_vulns[comm].append(vuln["package"])
        except ValueError:
            # Package is not in the graph
            pass

    return Counter(vuln_communities), community_vulns


def vulnerabilities_reach(graph, vulns):
    graph.vs["vuln_count"] = [0 for _ in range(len(graph.vs))]
    vuln_metrics = {}
    pr = np.array(graph.pagerank())

    for _, vuln in tqdm(
        vulns.iterrows(), desc="Enumerating vulnerabilities", total=len(vulns)
    ):
        try:
            vuln_id = graph.vs.find(name=vuln["package"]).index
            in_compoennt = graph.subcomponent(vuln_id, mode="in")
            for node in in_compoennt:
                graph.vs[node]["vuln_count"] += 1
            vuln_metrics[vuln["package"]] = {
                "reach": len(in_compoennt),
                "downloads": np.sum(np.array(graph.vs["downloads"])[in_compoennt]),
                "pagerank": np.sum(pr[in_compoennt]),
            }
        except ValueError:
            # Package is not in the graph
            pass

    return vuln_metrics


def print_cve_by_metric(
    graph,
    vuln_data,
    top_n=10,
    metric="reach",
    print_str="{cve} reached {value} packages ({percent:.2f}%)",
):
    top_cves = sorted(
        [(vuln, metrics[metric]) for vuln, metrics in vuln_data.items()],
        key=lambda x: x[1],
        reverse=True,
    )[:top_n]

    for cve, value in top_cves:
        print(
            print_str.format(cve=cve, value=value, percent=value / len(graph.vs) * 100)
        )


def print_top_pacakges_by_metric(graph, metric, temp, top_n=10):
    top_packages = sorted(
        [(graph.vs[i], metric[i]) for i in range(len(metric))],
        key=lambda x: x[1],
        reverse=True,
    )[:top_n]

    for package, value in top_packages:
        if "vuln_count" not in package.attributes():
            print(f"{package['name']}: {value}")
        else:
            print(
                f"{package['name']} ({package['vuln_count']}): {value} ({temp[package.index]})"
            )


graph = ig.Graph.Read_GraphML("../../networks/npm_prod_lcc.graphml")
vulns = pd.read_csv("../vulnerability/npm_grouped.csv")

downloads = []
for v in graph.vs:
    try:
        downloads.append(int(v["downloads"]))
    except ValueError:
        downloads.append(0)
graph.vs["downloads"] = downloads

vuln_compoennts = vulnerabilities_reach(graph, vulns)

df = pd.DataFrame(vuln_compoennts).T
df.to_csv("../results/vulnerability_metrics_npm_prod.csv")

print("Top CVEs by reach:")
print_cve_by_metric(graph, vuln_compoennts, top_n=10)
print()

print("Top CVEs by downloads:")
print_cve_by_metric(
    graph,
    vuln_compoennts,
    top_n=10,
    metric="downloads",
    print_str="{cve} could have reached {value} downloads",
)
print()

print("Top CVEs by pagerank:")
pr = np.array(graph.pagerank())
print_cve_by_metric(
    graph,
    vuln_compoennts,
    top_n=10,
    metric="pagerank",
    print_str="{cve} affected combined {value} pagerank",
)
print()

# print_top_pacakges_by_metric(graph, graph.pagerank(), top_n=10)

# communities = graph.as_undirected().community_leiden(
#     objective_function="modularity", n_iterations=-1
# )

# vulns_per_community, community_vulns = vulnerabilities_per_community(
#     graph, communities, vulns
# )

# for comm, count in vulns_per_community.most_common(5):
#     subgraph = graph.subgraph(communities[comm])
#     subgraph.vs["vuln_count"] = [0 for _ in range(len(subgraph.vs))]

#     for vuln in community_vulns[comm]:
#         vuln_id = subgraph.vs.find(name=vuln).index
#         in_compoennt = subgraph.subcomponent(vuln_id, mode="in")
#         subgraph.vs["vuln_count"] = [
#             vc + 1 if i in in_compoennt else vc
#             for i, vc in enumerate(subgraph.vs["vuln_count"])
#         ]

#     print(
#         f"Community {comm}: {count} vulnerabilities ({count / len(communities[comm])})"
#     )

#     vulns_graph = graph.subgraph(community_vulns[comm])
#     print("Vulns:")
#     print_top_pacakges_by_metric(vulns_graph, vulns_graph.vs["downloads"], top_n=10)
#     print("All community:")
#     print_top_pacakges_by_metric(subgraph, subgraph.pagerank(), top_n=10)
#     print()
